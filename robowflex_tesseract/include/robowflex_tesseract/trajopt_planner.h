/* Author: Carlos Quintero */

#ifndef ROBOWFLEX_TRAJOPT_PLANNER_
#define ROBOWFLEX_TRAJOPT_PLANNER_

#include <robowflex_library/class_forward.h>
#include <robowflex_library/builder.h>

#include <tesseract_planning/trajopt/trajopt_planner.h>
#include <tesseract_ros/ros_tesseract_utils.h>
#include <tesseract_ros/kdl/kdl_env.h>

#include <trajopt/file_write_callback.hpp>
#include <trajopt/problem_description.hpp>

namespace robowflex
{
    /** \cond IGNORE */
    ROBOWFLEX_CLASS_FORWARD(Robot);
    ROBOWFLEX_CLASS_FORWARD(Scene);
    ROBOWFLEX_CLASS_FORWARD(RobotTrajectory);
    ROBOWFLEX_CLASS_FORWARD(MotionRequestBuilder);
    /** \endcond */

    /** \cond IGNORE */
    ROBOWFLEX_CLASS_FORWARD(TrajOptPlanner);
    /** \endcond */

    /** \class robowflex::TrajOptPlannerPtr
        \brief A shared pointer wrapper for robowflex::TrajOptPlanner. */

    /** \class robowflex::TrajOptPlannerConstPtr
        \brief A const shared pointer wrapper for robowflex::TrajOptPlanner. */

    /** \brief Robowflex Tesseract TrajOpt Planner. 
        */
    class TrajOptPlanner
    {
    public:
        /** \brief Constructor.
            *  \param[in] robot Robot to plan for.
            *  \param[in] group_name Name of the group to plan for.
            */
        TrajOptPlanner(const RobotConstPtr &robot, const std::string &group_name, const std::string &manip);
        
        void giveInitialTrajectory(const trajopt::TrajArray &init_trajectory){initial_trajectory_ = init_trajectory;
                                                                              init_type_ = trajopt::InitInfo::Type::GIVEN_TRAJ;};
        
        bool plan(const SceneConstPtr &scene, 
                  const robot_state::RobotStatePtr &start_state, 
                  const robot_state::RobotStatePtr &goal_state);
                                                                              
        /** \brief Plan a motion given a \a request (start and goal configuration) and a \a scene.
        *  \param[in] scene A planning scene for the same \a robot_ to compute the plan in.
        *  \param[in] request The motion planning request to solve.
        *  \return The (tesseract) planner response generated by the planner.
        */
        bool plan(const SceneConstPtr &scene,
                  const MotionRequestBuilderPtr &request);
        
        /** \brief Plan a motion given a cartesian constraint for the end effector and a \a scene.
        *  \param[in] scene A planning scene for the same \a robot_ to compute the plan in.
        *  \param[in] start_state Start joint state of the motion.
        *  \param[in] goal_pose Cartesian pose of the end effector to plan for.
        *  \return The (tesseract) planner response generated by the planner.
        */
        bool plan(const SceneConstPtr &scene, 
                  const std::unordered_map<std::string, double> &start_state, 
                  const Eigen::Isometry3d &goal_pose, 
                  const std::string &link);
        
        /** \brief Plan a motion given a cartesian constraint for the end effector and a \a scene.
        *  \param[in] scene A planning scene for the same \a robot_ to compute the plan in.
        *  \param[in] start_state Start joint state of the motion.
        *  \param[in] goal_pose Cartesian pose of the end effector to plan for.
        *  \return The (tesseract) planner response generated by the planner.
        */
        bool plan(const SceneConstPtr &scene, 
                  const Eigen::Isometry3d &start_pose, 
                  const std::string &start_link, 
                  const Eigen::Isometry3d &goal_pose, 
                  const std::string &goal_link);
        
        void setWriteFile(bool file_write_cb, const std::string &file_path="");
        void printTesseractEnvLinks();
        void printManipulatorLinks();
        void printManipulatorJoints();
        
        /** \brief Get the trajectory that resulted in the last call to plan().
        *  \return Trajectory.
        */
        const robot_trajectory::RobotTrajectoryPtr getTrajectory(){return trajectory_;};
        
        /** \brief Set number of waypoints to be use.
        *  \param[in] numWaypoints Number of waypoints.
        */
        void setNumWaypoints(const int &num_waypoints){num_waypoints_ = num_waypoints;};
        void setInitType(const trajopt::InitInfo::Type &init_type);

    private:
        /** \brief Loads a new scene into the KDL env.
        *  \param[in] scene Scene to load.
        *  \param[in] name Name of the scene.
           \return True if env was correctly loaded from scene.
        */
        bool createTesseractEnvFromScene(const robowflex::SceneConstPtr &scene);
        
        /** \brief Updates the trajectory object based on the planner response.
        *  \param[in] response Tesseract planner response after calling solve()
        */
        void updateTrajFromTesseractRes(const tesseract::tesseract_planning::PlannerResponse &response);
        
        void problemConstructionInfo(std::shared_ptr<trajopt::ProblemConstructionInfo> &pci);
        void addCollisionAvoidance(std::shared_ptr<trajopt::ProblemConstructionInfo> &pci);
        void addGoalPose(const Eigen::Isometry3d &goal_pose, const std::string &link, 
                         std::shared_ptr<trajopt::ProblemConstructionInfo> &pci);
        void addGoalState(const std::vector<double> goal_state,
                          std::shared_ptr<trajopt::ProblemConstructionInfo> &pci);
        void addGoalState(const robot_state::RobotStatePtr &goal_state, 
                          std::shared_ptr<trajopt::ProblemConstructionInfo> &pci);
        void addGoalState(const MotionRequestBuilderPtr &request, 
                          std::shared_ptr<trajopt::ProblemConstructionInfo> &pci);
        void addStartPose(const Eigen::Isometry3d &start_pose, const std::string &link, 
                          std::shared_ptr<trajopt::ProblemConstructionInfo> &pci);
        void addStartState(const std::unordered_map<std::string, double> &start_state, 
                           std::shared_ptr<trajopt::ProblemConstructionInfo> &pci);
        void addStartState(const robot_state::RobotStatePtr &start_state, 
                           std::shared_ptr<trajopt::ProblemConstructionInfo> &pci);
        void addStartState(const MotionRequestBuilderPtr &request, 
                           std::shared_ptr<trajopt::ProblemConstructionInfo> &pci);
        void roboStateToManipState(const robot_state::RobotStatePtr &robot_state, 
                                   std::vector<double> &goal_state);
        void tesseractWaypointToRobotState(const Eigen::VectorXd &waypoint, 
                                           robot_state::RobotStatePtr &state);
        bool solve(const std::shared_ptr<trajopt::ProblemConstructionInfo> &pci);
        
        RobotConstPtr robot_;                                                       ///< Robot to plan for.
        robot_trajectory::RobotTrajectoryPtr trajectory_;                           ///< Last trajectory generated by the planner.
        std::shared_ptr<tesseract::tesseract_ros::KDLEnv> env_;                     ///< KDL environment.
        std::string group_;                                                         ///< Name of group to plan for.
        std::string manip_;                                                         ///< Name of manipulator chain to plan check for collisions.
        int num_waypoints_{20};                                                     ///< Number of waypoints
        bool cont_cc_{true};                                                        ///< Use continuous collision checking
        std::shared_ptr<std::ofstream> stream_ptr_;                                 ///< File stream
        bool file_write_cb_{false};                                                 ///< Whether to write a file or not
        std::string file_path_{""};                                                 ///< File path
        trajopt::InitInfo::Type init_type_{trajopt::InitInfo::Type::STATIONARY};
        trajopt::TrajArray initial_trajectory_;
    };
} // namespace robowflex


#endif
